//
//  ShowProfilePresenter.swift
//  Profile editor
//
//  Created by Warwick McNaughton on 8/02/19.
//  Copyright (c) 2019 Warwick McNaughton. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol ShowProfilePresentationLogic {
    func presentTriplesBySubject(response: ShowProfile.Profile.Response)
}

class ShowProfilePresenter: ShowProfilePresentationLogic {
    weak var viewController: ShowProfileDisplayLogic?
    var me: String?
    var hostURL: String?
    var fullName: String?
    
    
    // MARK: - VIP
    
    /*
     Passes an array of Sections to the ViewController.  The data in each Section will be used for each section in the tableview.
     The subject will be placed in the section header and each cell in the section will contain the predicate and object.
     First, enumerate triples to get info about 'me' and put this into the first section.
     Break out of enumeration when subject changes from me or get to end of triples.
     Continue enumeration of triples to get all other info.
     When subject changes form a new section.
     */
    func presentTriplesBySubject(response: ShowProfile.Profile.Response) {
        let triples = response.triples
        var sections = [Section]()
        var profileDocument: String?
        var subj: String?
        var tripleIndex = 0
        var currentSection: Section?
        // Get profile document
        for triple in triples! {
 //           let (subject, subjectType) = triple.subject
            let (predicate, _) = triple.predicate
            let (object, _) = triple.object
            if predicate.contains("http://www.w3.org/1999/02/22-rdf-syntax-ns#type") && (object.contains("http://xmlns.com/foaf/0.1/Document") || object.contains("http://xmlns.com/foaf/0.1/PersonalProfileDocument")) {
                profileDocument = triple.subject.0
                let documentURL = URL(string: profileDocument!)
                hostURL = documentURL!.host
                break
            }
        }
        
        // Get me
        for triple in triples! {
            let (subject, _) = triple.subject
            let (predicate, _) = triple.predicate
//            let (object, _) = triple.object
            if subject == profileDocument && predicate == "http://xmlns.com/foaf/0.1/primaryTopic" {
                me = triple.object.0
                break
            }
        }
        
        // Get full name
        for triple in triples! {
            let (subject, _) = triple.subject
            let (predicate, _) = triple.predicate
//            let (object, _) = triple.object
            if subject == me && predicate == "http://www.w3.org/2006/vcard/ns#fn" {
                fullName = triple.object.0
                subj = me
                currentSection = Section(name: fullName!)
                break
            }
        }
        
        // Having got name of the initial section for me as the subject, get all data to add to the section body.
        for triple in triples! {
            let (subject, subjectType) = triple.subject
//            let (predicate, _) = triple.predicate
//            let (object, _) = triple.object
            if subj != nil && subjectType != "BlankNode"{
                if subject == subj {
                    currentSection!.sectionData.append(getPredAndObjectFromTriple(triple: triple, triples: triples!))
                }
                else {
                    // Assumes once subject changes then save this section, break out and start a new one
                    sections.append(currentSection!)
                    break
                }
            }
            tripleIndex += 1
            if tripleIndex == triples?.count {
                if currentSection != nil {
                    sections.append(currentSection!)
                }
                break
            }
        }
        
        // Parse all triples starting after the me section
        currentSection = nil
        for index in tripleIndex..<triples!.count {
            let triple = triples![index]
            let (subject, _) = triple.subject
            if subject != subj {
                if currentSection != nil {
                    sections.append(currentSection!)
                }
                subj = subject
                currentSection = Section(name: subj!)
            }
            currentSection!.sectionData.append(getPredAndObjectFromTriple(triple: triple, triples: triples!))
            if index == triples?.count {
                sections.append(currentSection!)
            }
        }
        let viewModel = ShowProfile.Profile.ViewModel(sections: sections)
        viewController?.displaySections(viewModel: viewModel) 
    }
    
    
    
    // MARK: - Helpers
    
    /*
     From the triple, return a tuple consisting of a formatted predicate and object.
     If the predicate or object matches a declared prefix, then the Turtle prefix notation is used.
     The object is checked whether it references detail declared in another triple.
     */
    func getPredAndObjectFromTriple(triple: Triple, triples: [Triple]) -> (String, String, Int) {
        let predString = getPrefixSuffixFromURI(uri: triple.predicate.0)
        var objString: String?
        if triple.object.1 != "Literal" {
            objString = getPrefixSuffixFromURI(uri: triple.object.0)
            let objURL = URL(string: objString!)
            
            if objString!.contains("#") && objURL!.host == hostURL {
                if objString == me {
                    objString = fullName
                }
                else {
                    let idx1 = objString!.lastIndex(of: "#")
                    let  idxAfter = objString!.index(after: idx1!)
                    let ref = String(objString!.suffix(from: idxAfter))
                    if ref != "me" {
                        if let details = getDetailsFromReference(reference: ref, triples: triples) {
                            objString = details
                        }
                    }
                }
            }
            if triple.object.1 == "BlankNode" {
                objString = getDetailsFromReference(reference: objString!, triples: triples)
            }
        }
        else {
            objString = triple.object.0
        }
        return (predString, objString!, triple.index!)
    }
    
    
    func getPrefixSuffixFromURI(uri: String)->String {
        var prefix: String?
        var suffix: String?
        var suffixLength: Int?
        if uri.hasPrefix("http://xmlns.com/foaf/0.1/") {
            prefix = "foaf"
            suffixLength = uri.count - String("http://xmlns.com/foaf/0.1/").count
        }
        else if uri.hasPrefix("http://www.w3.org/2002/07/owl#") {
            prefix = "owl"
            suffixLength = uri.count - String("http://www.w3.org/2002/07/owl#").count
        }
        else if uri.hasPrefix("http://www.w3.org/1999/02/22-rdf-syntax-ns#") {
            prefix = "rdf"
            suffixLength = uri.count - String("http://www.w3.org/1999/02/22-rdf-syntax-ns#").count
        }
        else if uri.hasPrefix("http://www.w3.org/2000/01/rdf-schema#") {
            prefix = "rdfs"
            suffixLength = uri.count - String("http://www.w3.org/2000/01/rdf-schema#").count
        }
        else if uri.hasPrefix("http://schema.org/") {
            prefix = "schema"
            suffixLength = uri.count - String("http://schema.org/").count
        }
        else if uri.hasPrefix("http://www.w3.org/2006/vcard/ns#") {
            prefix = "vcard"
            suffixLength = uri.count - String("http://www.w3.org/2006/vcard/ns#").count
        }
        else if uri.hasPrefix("http://www.w3.org/ns/pim/space#") {
            prefix = "pim"
            suffixLength = uri.count - String("http://www.w3.org/ns/pim/space#").count
        }
        else if uri.hasPrefix("http://www.w3.org/ns/ldp#") {
            prefix = "ldp"
            suffixLength = uri.count - String("http://www.w3.org/ns/ldp#").count
        }
        else if uri.hasPrefix("http://www.w3.org/ns/solid/terms#") {
            prefix = "solid"
            suffixLength = uri.count - String("http://www.w3.org/ns/solid/terms#").count
        }
        else if uri.hasPrefix("http://dbpedia.org/ontology/") {
            prefix = "dbo"
            suffixLength = uri.count - String("http://dbpedia.org/ontology/").count
        }
        else if uri.hasPrefix("http://dbpedia.org/resource/") {
            prefix = "dbp"
            suffixLength = uri.count - String("http://dbpedia.org/resource/").count
        }
        else if uri.hasPrefix("http://purl.org/dc/terms/") {
            prefix = "dc"
            suffixLength = uri.count - String("http://purl.org/dc/terms/").count
        }
        else if uri.hasPrefix("http://www.w3.org/ns/dcat#") {
            prefix = "dcat"
            suffixLength = uri.count - String("http://www.w3.org/ns/dcat#").count
        }
            
        else if uri.hasPrefix("http://www.w3.org/2000/10/swap/pim/contact#") {
            prefix = "con"
            suffixLength = uri.count - String("http://www.w3.org/2000/10/swap/pim/contact#").count
        }
        else {
            return uri
        }
        suffix = String(uri.suffix(suffixLength!))
        return prefix! + ":" + suffix!
    }
    
    
    /*
     Searches all triples to find a triple with a subject containing the passed-in reference.
     */
    func getDetailsFromReference(reference: String, triples: [Triple] ) ->String? {
        var detail: String?
        for triple in triples {
            if triple.subject.0.contains(reference) {
                if detail == nil { detail = String()}
                if detail!.count > 0 {
                    detail?.append(", ")
                }
                detail!.append(triple.object.0)
            }
        }
        return detail
    }
}

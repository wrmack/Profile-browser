//
//  ShowProfilePresenter.swift
//  Profile editor
//
//  Created by Warwick McNaughton on 8/02/19.
//  Copyright (c) 2019 Warwick McNaughton. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol ShowProfilePresentationLogic {
    func presentTriplesBySubject(response: ShowProfile.Profile.Response)
}

class ShowProfilePresenter: ShowProfilePresentationLogic {
    weak var viewController: ShowProfileDisplayLogic?
    var me: String?
    var meFragment: String?
    var hostURL: String?
    var formattedName: String?
    
    
    // MARK: - VIP
    
    /*
     Passes an array of Sections ([Section]) to the ViewController to display as table sections.
     The data in each Section will be used for each section in the tableview.
     The subject will be placed in the section header and each cell in the section will contain the predicate and object associated
     for that subject.
     First, enumerate triples to get info about 'me' and put this into the first section.
     Break out of enumeration when subject changes from me or get to end of triples.
     Continue enumeration of triples to get all other info.
     When subject changes form a new section, placing the subject into the section name (which will be displayed in the section header).
     */
    func presentTriplesBySubject(response: ShowProfile.Profile.Response) {
        let triples = response.triples
        var sections = [Section]()
        var profileDocument: String?
        var subj: String?
        var currentSection: Section?
        // Get profile document
        for triple in triples! {
 //           let (subject, subjectType) = triple.subject
            let (predicate, _) = triple.predicate
            let (object, _, _) = triple.object
            if predicate.contains("http://www.w3.org/1999/02/22-rdf-syntax-ns#type") && (object.contains("http://xmlns.com/foaf/0.1/Document") || object.contains("http://xmlns.com/foaf/0.1/PersonalProfileDocument")) {
                profileDocument = triple.subject.0
                let documentURL = URL(string: profileDocument!)
                hostURL = documentURL!.host
                break
            }
        }
        
        // Get me
        for triple in triples! {
            let (subject, _) = triple.subject
            let (predicate, _) = triple.predicate
            if subject == profileDocument && predicate == "http://xmlns.com/foaf/0.1/primaryTopic" {
                me = triple.object.0
                if me!.contains("#") {
                    let idx1 = me!.lastIndex(of: "#")
                    let  idxAfter = me!.index(after: idx1!)
                    meFragment = String(me!.suffix(from: idxAfter))
                }
                break
            }
        }
        
        // Get formatted name
        for triple in triples! {
            let (subject, _) = triple.subject
            let (predicate, _) = triple.predicate
            if subject == me && predicate == "http://www.w3.org/2006/vcard/ns#fn" {
                formattedName = triple.object.0
                subj = me
                currentSection = Section(name: formattedName!)
                break
            }
        }
        
        // Having got name of the initial section for 'me' as the subject, get all data to add to the section body.
        if me != nil {
            for triple in triples! {
                let (subject, _) = triple.subject
                if subject == me! {
                    if currentSection == nil {
                        currentSection = Section(name: me!)
                    }
                    currentSection!.sectionData.append(getPredAndObjectFromTriple(triple: triple, triples: triples!))
                }
            }
            if currentSection != nil {
                 sections.append(currentSection!)
            }
        }
        
        // Parse all triples not being about me
        currentSection = nil
        subj = nil
        
        for triple in triples! {

            if triple.subject.0 != me {
                
                guard let subject = getSubjectFromTriple(triple: triple, triples: triples!) else { continue}

                // Starting off
                if currentSection == nil {
                    currentSection = Section(name: subject)
                    subj = subject
                }
                // Change of subject
                if subject != subj!  {
                    sections.append(currentSection!)
                    subj = subject
                    currentSection = Section(name: subj!)
                }
                currentSection!.sectionData.append(getPredAndObjectFromTriple(triple: triple, triples: triples!))
            }
        }
        sections.append(currentSection!)
        let viewModel = ShowProfile.Profile.ViewModel(sections: sections)
        viewController?.displaySections(viewModel: viewModel) 
    }
    
    
    
    // MARK: - Helpers
    
    func getSubjectFromTriple(triple: Triple, triples: [Triple]) -> (String?) {
        if triple.subject.1 == "Literal" {
            return triple.subject.0
        }
        let subjectString = triple.subject.0
        let objURL = URL(string: subjectString)
        if subjectString.contains("#") { //&& objURL!.host == hostURL {
            if subjectString == me {
                return formattedName
            }
            else {
                let idx1 = subjectString.lastIndex(of: "#")
                let  idxAfter = subjectString.index(after: idx1!)
                let fragment = String(subjectString.suffix(from: idxAfter))
                if fragment != meFragment {
                    let isReference = checkIfReference(fragment: fragment, triples: triples)
                    if isReference == true {
                        return nil
                    }
                }
            }
        }
        if subjectString.first == "_" {
            let isReference = checkIfReference(fragment: subjectString, triples: triples)
            if isReference == true {
                return nil
            }
        }
       return triple.subject.0
    }
    
    
    /*
     From the triple, return a tuple consisting of a formatted predicate and object.
     If the predicate or object matches a declared prefix, then the Turtle prefix notation is used.
     The object is checked whether it references detail declared in another triple.
     */
    func getPredAndObjectFromTriple(triple: Triple, triples: [Triple]) -> (String, String, Int) {
        let predString = getPrefixSuffixFromURI(uri: triple.predicate.0)
        let friendlyPredString = NSLocalizedString(predString, tableName: "Friendly", bundle: Bundle.main, value: "", comment: "Friendly predicate")
        var objString: String?
        if triple.object.1 != "Literal" {
            objString = getPrefixSuffixFromURI(uri: triple.object.0)
            let objURL = URL(string: objString!)
            
            if objString!.contains("#") && objURL!.host == hostURL {
                if objString == me && formattedName != nil {
                    objString = formattedName
                }
                else {
                    let idx1 = objString!.lastIndex(of: "#")
                    let  idxAfter = objString!.index(after: idx1!)
                    let ref = String(objString!.suffix(from: idxAfter))
                    if ref != meFragment {
                        if let details = getDetailsFromReference(reference: ref, triples: triples) {
                            objString = details
                        }
                    }
                }
            }
            if triple.object.1 == "BlankNode" {
                objString = getDetailsFromReference(reference: objString!, triples: triples)
            }
        }
        else {
            objString = triple.object.0
            if triple.object.2 != nil {
                let lang = NSLocalizedString(triple.object.2!, tableName: "Language", bundle: Bundle.main, value: "", comment: "")
                objString?.append(" (\(lang))")
            }
        }
        return (friendlyPredString, objString!, triple.index)
    }
    
    
    func getPrefixSuffixFromURI(uri: String)->String {
        var longPrefix = uri
        
        switch uri {

        case _ where uri.hasPrefix("http://www.w3.org/ns/dcat#"):
            longPrefix = "http://www.w3.org/ns/dcat#"

        case _ where uri.hasPrefix("http://www.w3.org/2002/07/owl#"):
            longPrefix = "http://www.w3.org/2002/07/owl#"
        
        case _ where uri.hasPrefix("http://www.w3.org/1999/02/22-rdf-syntax-ns#"):
             longPrefix = "http://www.w3.org/1999/02/22-rdf-syntax-ns#"
        
        case _ where uri.hasPrefix("http://www.w3.org/2000/01/rdf-schema#"):
             longPrefix = "http://www.w3.org/2000/01/rdf-schema#"
        
        case _ where uri.hasPrefix("http://www.w3.org/2006/vcard/ns#"):
            longPrefix = "http://www.w3.org/2006/vcard/ns#"
        
        case _ where uri.hasPrefix("http://www.w3.org/ns/pim/space#"):
            longPrefix = "http://www.w3.org/ns/pim/space#"
        
        case _ where uri.hasPrefix("http://www.w3.org/ns/ldp#"):
            longPrefix = "http://www.w3.org/ns/ldp#"
        
        case _ where uri.hasPrefix("http://www.w3.org/ns/solid/terms#"):
            longPrefix = "http://www.w3.org/ns/solid/terms#"
            
        case _ where uri.hasPrefix("http://www.w3.org/ns/org#"):
            longPrefix = "http://www.w3.org/ns/org#"
            
        case _ where uri.hasPrefix("http://www.w3.org/ns/auth/cert#"):
            longPrefix = "http://www.w3.org/ns/auth/cert#"
            
        case _ where uri.hasPrefix("http://www.w3.org/ns/auth/acl#"):
            longPrefix = "http://www.w3.org/ns/auth/acl#"
            
        case _ where uri.hasPrefix("http://www.w3.org/2000/10/swap/pim/contact#"):
            longPrefix = "http://www.w3.org/2000/10/swap/pim/contact#"
            
        case _ where uri.hasPrefix("http://xmlns.com/foaf/0.1/"):
            longPrefix = "http://xmlns.com/foaf/0.1/"
            
        case _ where uri.hasPrefix("http://schema.org/"):
            longPrefix = "http://schema.org/"
            
        case _ where uri.hasPrefix("http://dbpedia.org/ontology/"):
            longPrefix = "http://dbpedia.org/ontology/"
            
        case _ where uri.hasPrefix("http://dbpedia.org/resource/"):
            longPrefix = "http://dbpedia.org/resource/"
            
        case _ where uri.hasPrefix("http://purl.org/dc/terms/"):
            longPrefix = "http://purl.org/dc/terms/"
            
        case _ where uri.hasPrefix("http://purl.org/dc/elements/1.1/"):
            longPrefix = "http://purl.org/dc/elements/1.1/"
            
        case _ where uri.hasPrefix("http://creativecommons.org/ns#"):
            longPrefix = "http://creativecommons.org/ns#"

        case _ where uri.hasPrefix("http://www.w3.org/2003/01/geo/wgs84_pos#"):
            longPrefix = "http://www.w3.org/2003/01/geo/wgs84_pos#"

        default:
            break
        }
        if longPrefix != uri {
            let prefix = NSLocalizedString(longPrefix, tableName: "Prefix", bundle: Bundle.main, value: "", comment: "")
            let suffix = uri.components(separatedBy: longPrefix).last
            return "\(prefix):\(suffix!)"
        }
        return uri
    }
    
    
    /*
     Searches all triples to find a triple with a subject containing the passed-in reference.
     */
    func getDetailsFromReference(reference: String, triples: [Triple] ) ->String? {
        var detail: String?
        for triple in triples {
            if triple.subject.0.contains(reference) {
                if detail == nil { detail = String()}
                if detail!.count > 0 {
                    detail?.append(", ")
                }
                detail!.append(triple.object.0)
            }
        }
        return detail
    }
    
    
    func checkIfReference(fragment: String, triples: [Triple] ) -> Bool {
        for triple in triples {
            if triple.object.0.contains(fragment) {
                return true
            }
        }
        return false
    }
}

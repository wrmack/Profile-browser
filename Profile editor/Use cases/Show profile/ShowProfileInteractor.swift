//
//  ShowProfileInteractor.swift
//  Profile editor
//
//  Created by Warwick McNaughton on 8/02/19.
//  Copyright (c) 2019 Warwick McNaughton. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import JavaScriptCore



protocol ShowProfileBusinessLogic {
    func fetchProfile(request: ShowProfile.Profile.Request)
    func getStoreTriples()-> [Triple]?
    func addSelectedItemToDataStore(item: (String, String, Int))
}

protocol ShowProfileDataStore {
    var storeTriples: [Triple]? {get set}
    var selectedItem: Triple? {get set}
    var context: JSContext? {get set}
    var webid: String? {get set}
}



class ShowProfileInteractor: NSObject, ShowProfileBusinessLogic, ShowProfileDataStore, URLSessionDelegate {
    var presenter: ShowProfilePresentationLogic?
    var worker: ShowProfileWorker?
    var context: JSContext?
    var storeTriples: [Triple]?
    var selectedItem: Triple?
    var webid: String?
    

    // MARK: - VIP
    
    func fetchProfile(request: ShowProfile.Profile.Request) {
        webid = request.webid
        if context == nil { setupContext(); setupRdfLib()}
        let url = URL(string: request.webid! )
        fetch(url: url!, callback: { response, mimetype in
            print("Mime-type: \(mimetype)")
            print("Data: \n\(response)")
            self.context?.evaluateScript("var store = RDF.graph();")
            self.context?.evaluateScript("RDF.parse(`" + response + "`, store, '" + request.webid! + "', 'text/turtle');")
            let statementsArray = self.context!.objectForKeyedSubscript("store")!.toDictionary()!["statements"] as! [Any]
            //            print("Store statements: \(statementsArray)")
            var triples = [Triple]()
            var count = 0
            for item in statementsArray {
                if let tripleDictionary = item as? [String : Any] {
                    let subject = (tripleDictionary["subject"] as! [String : Any])["value"] as! String
                    let subjectType = (tripleDictionary["subject"] as! [String : Any])["termType"] as! String
                    let predicate = (tripleDictionary["predicate"] as! [String : Any])["value"] as! String
                    let predicateType = (tripleDictionary["predicate"] as! [String : Any])["termType"] as! String
                    let objectType = (tripleDictionary["object"] as! [String : Any])["termType"] as! String
                    var object: String?
                    switch objectType {
                    case "NamedNode":
                        object = (tripleDictionary["object"] as! [String : Any])["value"] as? String
                    case "Literal":
                        object = (tripleDictionary["object"] as! [String : Any])["value"] as? String
                    case "Collection":
                        object = "Collection placeholder"
                    case "BlankNode":
                        object = (tripleDictionary["object"] as! [String : Any])["value"] as? String
                    default:
                        object = "Missing object"
                    }
                    let triple = Triple(index: count, subject: (subject, subjectType), predicate:( predicate, predicateType), object: (object!, objectType))
                    triples.append(triple)
                    count += 1
                }
            }
            print("Triples derived from parsing store statements: ")
            for triple in triples {
                print(triple)
            }
            // Uncomment below to print the store rdf data as triples
            //            self.context?.evaluateScript("var triples = store.toNT();")
            //            let storeTriples = self.context?.objectForKeyedSubscript("triples")
            //            print("Store triples: \n\(storeTriples!)")
            DispatchQueue.main.async {
                self.storeTriples = triples
                let response = ShowProfile.Profile.Response(triples: triples)
                self.presenter?.presentTriplesBySubject(response: response) 
            }
        })
    }
    
    
    // MARK: - Datastore
    
    func getStoreTriples()-> [Triple]? {
        return storeTriples
    }
    
    func addSelectedItemToDataStore(item: (String, String, Int)) {
        let (_, _, idx) = item
        for triple in storeTriples! {
            if triple.index == idx {
                selectedItem = triple
                break
            }
        }
    }
    
    
    // MARK: - Helpers
    
    /*
     Setup the javascript context
     */
    func setupContext() {
        
        context = JSContext()
        
        // Catch JavaScript exceptions
        context!.exceptionHandler = { context, error in
            print("JS Error: \(error!)")
        }
        
        let nativePrint: @convention(block) (String) -> Void = { message in
            print("JS print: \(message)")
        }
        context!.setObject(nativePrint, forKeyedSubscript: "nativePrint" as NSString)
    }
    
    
    /*
     Write the bundled javascript RDF library into the javascript context.
     Note: the bundle was created with browserify standalone option set to "RDF".
     All exports in index.js are available to Swift through RDF.
     Setup the store in javascript.
     */
    func setupRdfLib() {
        
        guard let rdfPath = Bundle.main.path(forResource: "rdfbundle", ofType: "js")
            else { print("Unable to read resource files."); return }
        
        do {
            let jsCode = try String(contentsOfFile: rdfPath, encoding: String.Encoding.utf8)
            _ = context?.evaluateScript(jsCode)
        }
        catch {
            print("Evaluate script failed")
        }
    }
    
    /*
     Url fetcher with callback
     */
    func fetch(url: URL, callback: @escaping (String, String) -> Void) {
        let session = URLSession(configuration: .default, delegate: self, delegateQueue: nil)
        let task = session.dataTask(with: url) { data, response, error in
            if let error = error {
                print(error)
                return
            }
            print("\nResponse:\n\(response! as Any)")
            guard let httpResponse = response as? HTTPURLResponse,
                (200...299).contains(httpResponse.statusCode) else {
                    print((response as? HTTPURLResponse)?.allHeaderFields as! [String : Any] )
                    return
            }
            print("\nAll headers:\n\(httpResponse.allHeaderFields as! [String : Any])")
            
            let string = String(data: data!, encoding: .utf8)
            callback(string!, httpResponse.mimeType!)
        }
        task.resume()
    }
    
    
    // MARK: - URLSessionDelegate methods
    func urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
        completionHandler(.useCredential, URLCredential(trust: challenge.protectionSpace.serverTrust!)
        )
    }
    
}
